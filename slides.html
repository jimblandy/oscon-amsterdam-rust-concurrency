<?xml version="1.0" ?><!DOCTYPE HTML><html lang="en"><head><title>Concurrency First in Rust</title><meta charset="utf-8"/><meta content="width=792, user-scalable=no" name="viewport"/><meta content="ie=edge" http-equiv="x-ua-compatible"/><link href="shower/themes/ribbon/styles/screen.css" rel="stylesheet"/><link href="custom.css" rel="stylesheet"/></head><body class="list"><header class="caption"><h1>Concurrency First in Rust</h1><p>Jim Blandy</p></header><section class="slide cover" id="Cover"><div><h2>Concurrency First in Rust</h2><p>Jim Blandy &lt;jimb@mozilla.com&gt; @jimblandy</p><img alt="" src="images/cover.png"/><style>
                           #Cover h2 {
                                   margin:30px 0 0;
                                   color:#FFF;
                                   text-align:center;
                                   font-size:70px;
                                   }
                           #Cover p {
                                   margin:10px 0 0;
                                   text-align:center;
                                   color:#FFF;
                                   font-style:italic;
                                   font-size:20px;
                                   }
                           #Cover p a {
                                   color:#FFF;
                                   }
                           </style></div></section><section class="slide big"><div><p/><p>Rust makes concurrent designs easier to explore, implement, and maintain, by
guaranteeing the absence of data races and memory corruption.
</p></div></section><section class="slide"><div><h2>Why Rust?</h2><ul><li>safety: no dangling pointers, no buffer overruns</li><li>performance: the programmer has control</li><li>concurrency: exploit multi-threaded machines</li></ul></div></section><section class="slide"><div><h2>How does Rust accomplish those goals?</h2><ul><li class="next">statically typed language</li><li class="next">ahead-of-time compiler (no JIT)</li><li class="next">memory freed at well-defined points (no GC)</li><li class="next">“traits” capture common characteristics of types</li><li class="next">generic functions everywhere, compiled by specialization</li><li class="next">generic type parameters checked by traits</li></ul></div></section><section class="slide"><div><h2>Rust aims to compete with C++</h2><figure><blockquote><p>In general, C++ implementations obey the zero-overhead principle: What
you don’t use, you don’t pay for. And further: What you do use, you
couldn’t hand code any better.
</p></blockquote><figcaption>Bjarne Stroustrup</figcaption></figure><p class="next">This is Rust's principle as well.
</p></div></section><section class="slide"><div><h2>A simple Rust function</h2><pre><code>fn gcd(mut n: u64, mut m: u64) -&gt; u64 {
    assert!(n != 0 &amp;&amp; m != 0);
    while m != 0 {
        if m &lt; n {
            let t = m; m = n; n = t;
        }
        m = m % n;
    }
    n   
}
</code></pre></div></section><section class="slide"><div><h2>A simple Rust function</h2><pre><code>fn gcd(mut n: <span class="highlighted">u64</span>, mut m: <span class="highlighted">u64</span>) -&gt; <span class="highlighted">u64</span> {
    assert!(n != 0 &amp;&amp; m != 0);
    while m != 0 {
        if m &lt; n {
            let t = m; m = n; n = t;
        }
        m = m % n;
    }
    n   
}
</code></pre></div></section><section class="slide"><div><h2>A simple Rust function</h2><pre><code>fn gcd(mut n: u64, mut m: u64) -&gt; u64 {
    assert!(n != 0 &amp;&amp; m != 0);
    while m != 0 {
        if m &lt; n {
            <span class="highlighted">let t = m;</span> m = n; n = t;
        }
        m = m % n;
    }
    n   
}
</code></pre></div></section><section class="slide"><div><h2>A simple Rust function</h2><pre><code>fn gcd(mut n: u64, mut m: u64) -&gt; u64 {
    assert!(n != <span class="highlighted">0</span> &amp;&amp; m != <span class="highlighted">0</span>);
    while m != <span class="highlighted">0</span> {
        if m &lt; n {
            let t = m; m = n; n = t;
        }
        m = m % n;
    }
    n   
}
</code></pre></div></section><section class="slide"><div><h2>A simple Rust function</h2><pre><code>fn gcd(mut n: u64, mut m: u64) -&gt; u64 {
    assert!(n != 0 &amp;&amp; m != 0);
    while m != 0 {
        if m &lt; n {
            let t = m; m = n; n = t;
        }
        m = m % n;
    }
 <span class="highlighted">   n   </span>
}
</code></pre></div></section><section class="slide"><div><h2>Rust <code>enum</code> types, aka algebraic types</h2><pre><code>enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre></div></section><section class="slide"><div><h2>Rust <code>enum</code> types, aka algebraic types</h2><pre><code>enum Option<span class="highlighted">&lt;T&gt;</span> {
    None,
    Some(T),
}
</code></pre></div></section><section class="slide"><div><h2>Rust <code>enum</code> types, aka algebraic types</h2><pre><code>enum Option&lt;T&gt; {
    <span class="highlighted">None</span>,
    Some(T),
}
</code></pre></div></section><section class="slide"><div><h2>Rust <code>enum</code> types, aka algebraic types</h2><pre><code>enum Option&lt;T&gt; {
    None,
    <span class="highlighted">Some(T)</span>,
}
</code></pre></div></section><section class="slide"><div><h2>A safe division function</h2><pre><code>fn safe_div(n: i32, d: i32) -&gt; Option&lt;i32&gt; {
    if d == 0 {
        return None;
    }
    return Some(n / d);
}
</code></pre></div></section><section class="slide"><div><h2>A safe division function</h2><pre><code>fn safe_div(n: i32, d: i32) -&gt; <span class="highlighted">Option&lt;i32&gt;</span> {
    if d == 0 {
        return None;
    }
    return Some(n / d);
}
</code></pre></div></section><section class="slide"><div><h2>A safe division function</h2><pre><code>fn safe_div(n: i32, d: i32) -&gt; Option&lt;i32&gt; {
    if d == 0 {
        return <span class="highlighted">None</span>;
    }
    return Some(n / d);
}
</code></pre></div></section><section class="slide"><div><h2>A safe division function</h2><pre><code>fn safe_div(n: i32, d: i32) -&gt; Option&lt;i32&gt; {
    if d == 0 {
        return None;
    }
    return <span class="highlighted">Some(n / d)</span>;
}
</code></pre></div></section><section class="slide"><div><h2>A safe division function</h2><pre><code>fn safe_div(n: i32, d: i32) -&gt; Option&lt;i32&gt; {
    if d == 0 {
        return None;
    }
    return Some(n / d);
}

match safe_div(24, 3) {
    None =&gt; println!(&quot;No quotient.&quot;),
    Some(v) =&gt; println!(&quot;quotient is {}&quot;, v)
}
</code></pre></div></section><section class="slide"><div><h2>A safe division function</h2><pre><code>fn safe_div(n: i32, d: i32) -&gt; Option&lt;i32&gt; {
    if d == 0 {
        return None;
    }
    return Some(n / d);
}

<span class="highlighted">match</span> safe_div(24, 3) {
    None =&gt; println!(&quot;No quotient.&quot;),
    Some(v) =&gt; println!(&quot;quotient is {}&quot;, v)
}
</code></pre></div></section><section class="slide"><div><h2>A safe division function</h2><pre><code>fn safe_div(n: i32, d: i32) -&gt; Option&lt;i32&gt; {
    if d == 0 {
        return <span class="highlighted">None</span>;
    }
    return Some(n / d);
}

match safe_div(24, 3) {
    <span class="highlighted">None</span> =&gt; println!(&quot;No quotient.&quot;),
    Some(v) =&gt; println!(&quot;quotient is {}&quot;, v)
}
</code></pre></div></section><section class="slide"><div><h2>A safe division function</h2><pre><code>fn safe_div(n: i32, d: i32) -&gt; Option&lt;i32&gt; {
    if d == 0 {
        return None;
    }
    return Some(n / d);
}

match safe_div(24, 3) {
    None =&gt; <span class="highlighted">println!(&quot;No quotient.&quot;)</span>,
    Some(v) =&gt; println!(&quot;quotient is {}&quot;, v)
}
</code></pre></div></section><section class="slide"><div><h2>A safe division function</h2><pre><code>fn safe_div(n: i32, d: i32) -&gt; Option&lt;i32&gt; {
    if d == 0 {
        return None;
    }
    return <span class="highlighted">Some(n / d)</span>;
}

match safe_div(24, 3) {
    None =&gt; println!(&quot;No quotient.&quot;),
    <span class="highlighted">Some(v)</span> =&gt; println!(&quot;quotient is {}&quot;, v)
}
</code></pre></div></section><section class="slide"><div><h2>A safe division function</h2><pre><code>fn safe_div(n: i32, d: i32) -&gt; Option&lt;i32&gt; {
    if d == 0 {
        return None;
    }
    return Some(n / d);
}

match safe_div(24, 3) {
    None =&gt; println!(&quot;No quotient.&quot;),
    Some(v) =&gt; <span class="highlighted">println!(&quot;quotient is {}&quot;, v)</span>
}
</code></pre></div></section><section class="slide"><div><h2>Results from fallible operations</h2><pre><code>#[must_use]
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre></div></section><section class="slide"><div><h2>Results from fallible operations</h2><pre><code>#[must_use]
enum Result<span class="highlighted">&lt;T, E&gt;</span> {
    Ok(T),
    Err(E),
}
</code></pre></div></section><section class="slide"><div><h2>Results from fallible operations</h2><pre><code>#[must_use]
enum Result&lt;T, E&gt; {
    <span class="highlighted">Ok(T)</span>,
    Err(E),
}
</code></pre></div></section><section class="slide"><div><h2>Results from fallible operations</h2><pre><code>#[must_use]
enum Result&lt;T, E&gt; {
    Ok(T),
    <span class="highlighted">Err(E)</span>,
}
</code></pre></div></section><section class="slide"><div><h2>Shareable references and mutable references</h2><pre><code>let i = 42;
let shareable = &amp;i;

let mut j = 1729;
let mutable = &amp;mut j;
</code></pre></div></section><section class="slide"><div><h2>Shareable references and mutable references</h2><pre><code>let i = 42;
let shareable = <span class="highlighted">&amp;i</span>;

let mut j = 1729;
let mutable = &amp;mut j;
</code></pre></div></section><section class="slide"><div><h2>Shareable references and mutable references</h2><pre><code>let i = 42;
let shareable = &amp;i;

let mut j = 1729;
let mutable = <span class="highlighted">&amp;mut j</span>;
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str) -&gt; Result&lt;()&gt; {
    let file = try!(File::open(path));
    let buffered = BufReader::new(file);
    for line in buffered.lines() {
        let line = try!(line);
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
    return Ok(());
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str) -&gt; <span class="highlighted">Result&lt;()&gt;</span> {
    let file = try!(File::open(path));
    let buffered = BufReader::new(file);
    for line in buffered.lines() {
        let line = try!(line);
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
    return Ok(());
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str) -&gt; Result&lt;<span class="highlighted">()</span>&gt; {
    let file = try!(File::open(path));
    let buffered = BufReader::new(file);
    for line in buffered.lines() {
        let line = try!(line);
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
    return Ok(());
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str) -&gt; Result&lt;()&gt; {
    let file = <span class="highlighted">try!</span>(File::open(path));
    let buffered = BufReader::new(file);
    for line in buffered.lines() {
        let line = try!(line);
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
    return Ok(());
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str) -&gt; Result&lt;()&gt; {
    let file = try!(File::open(path));
    let buffered = <span class="highlighted">BufReader::new(file);</span>
    for line in buffered.lines() {
        let line = try!(line);
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
    return Ok(());
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str) -&gt; Result&lt;()&gt; {
    let file = try!(File::open(path));
    let buffered = BufReader::new(file);
    <span class="highlighted">for line in buffered.lines()</span> {
        let line = try!(line);
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
    return Ok(());
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str) -&gt; Result&lt;()&gt; {
    let file = try!(File::open(path));
    let buffered = BufReader::new(file);
    for line in buffered.lines() {
        let line = <span class="highlighted">try!</span>(line);
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
    return Ok(());
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str) -&gt; Result&lt;()&gt; {
    let file = try!(File::open(path));
    let buffered = BufReader::new(file);
    for line in buffered.lines() {
        let line = try!(line);
        if <span class="highlighted">line.contains(pattern)</span> {
            println!(&quot;{}&quot;, line);
        }
    }
    return Ok(());
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str) -&gt; Result&lt;()&gt; {
    let file = try!(File::open(path));
    let buffered = BufReader::new(file);
    for line in buffered.lines() {
        let line = try!(line);
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
    <span class="highlighted">return Ok(());</span>
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str) -&gt; Result&lt;()&gt; {
    let file = try!(File::open(path));
    let buffered = BufReader::new(file);
    for line in buffered.lines() {
        let line = try!(line);
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
    <span class="highlighted">Ok(())</span>
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>for file in args {
    match grep(&amp;file, &amp;pattern) {
        Err(e) =&gt; {
            writeln!(std::io::stderr(),
                     &quot;Error searching {}: {}&quot;, file, e)
                .unwrap();
        },
        Ok(_) =&gt; ()
    }
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code><span class="highlighted">for file in args</span> {
    match grep(&amp;file, &amp;pattern) {
        Err(e) =&gt; {
            writeln!(std::io::stderr(),
                     &quot;Error searching {}: {}&quot;, file, e)
                .unwrap();
        },
        Ok(_) =&gt; ()
    }
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>for file in args {
    match <span class="highlighted">grep(&amp;file, &amp;pattern)</span> {
        Err(e) =&gt; {
            writeln!(std::io::stderr(),
                     &quot;Error searching {}: {}&quot;, file, e)
                .unwrap();
        },
        Ok(_) =&gt; ()
    }
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>for file in args {
    match grep(&amp;file, &amp;pattern) {
        <span class="highlighted">Err(e)</span> =&gt; {
            writeln!(std::io::stderr(),
                     &quot;Error searching {}: {}&quot;, file, e)
                .unwrap();
        },
        Ok(_) =&gt; ()
    }
}
</code></pre></div></section><section class="slide"><div><h2>A single-threaded grep</h2><pre><code>for file in args {
    match grep(&amp;file, &amp;pattern) {
        Err(e) =&gt; {
            writeln!(std::io::stderr(),
                     &quot;Error searching {}: {}&quot;, file, e)
                .unwrap();
        },
        <span class="highlighted">Ok(_) =&gt; ()</span>
    }
}
</code></pre></div></section><section class="slide"><div><h2>Thread Pools</h2><img alt="" src="images/thread-pool.svg"/></div></section><section class="slide"><div><h2>Channels</h2><img alt="" src="images/channels.svg"/></div></section><section class="slide"><div><h2>Forbidding data races</h2><p>Data races can only occur when data is both shared and mutable. So you can have either:
</p><center>Sharing without mutability
</center><center><b>or</b>
</center><center>Mutability without sharing
</center></div></section><section class="slide"><div><h2>Forbidding data races</h2><ul><li>If you send a mutable value on a channel, you must give up your pointers to it.</li><li>You can send pointers to immutable values to other threads, and both share access.</li></ul><p class="next">We'll see examples of both.
</p></div></section><section class="slide cover bigpicture"><div><img alt="" src="images/cargo-home-page.png"/></div></section><section class="slide cover bigpicture"><div><img alt="" src="images/cargo-search-results.png"/></div></section><section class="slide cover bigpicture"><div><img alt="" src="images/cargo-scoped_threadpool.png"/></div></section><section class="slide cover bigpicture"><div><img alt="" src="images/cargo-scoped_threadpool-dependency.png"/></div></section><section class="slide"><div><h2>The <code>Cargo.toml</code> file</h2><pre><code>[package]
name = &quot;pgrep&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Jim Blandy &lt;jimb@red-bean.com&gt;&quot;]

[dependencies]
scoped_threadpool = &quot;0.1.6&quot;
</code></pre></div></section><section class="slide"><div><h2>The <code>Cargo.toml</code> file</h2><pre><code>[package]
name = &quot;pgrep&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Jim Blandy &lt;jimb@red-bean.com&gt;&quot;]

[dependencies]
<span class="highlighted">scoped_threadpool = &quot;0.1.6&quot;</span>
</code></pre></div></section><section class="slide cover bigpicture"><div><img alt="" src="images/cargo-build-pgrep.png"/></div></section><section class="slide"><div><h2>A multi-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str,
        results: &amp;Sender&lt;Message&gt;) -&gt; Result&lt;()&gt;
{
    let file = try!(File::open(path));
    let buffered = BufReader::new(file);
    for line in buffered.lines() {
        let line = try!(line);
        if line.contains(pattern) {
            results.send(Message::Hit(line)).unwrap();
        }
    }
    return Ok(());
}
</code></pre></div></section><section class="slide"><div><h2>A multi-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str,
        <span class="highlighted">results: &amp;Sender&lt;Message&gt;</span>) -&gt; Result&lt;()&gt;
{
    let file = try!(File::open(path));
    let buffered = BufReader::new(file);
    for line in buffered.lines() {
        let line = try!(line);
        if line.contains(pattern) {
            results.send(Message::Hit(line)).unwrap();
        }
    }
    return Ok(());
}
</code></pre></div></section><section class="slide"><div><h2>A multi-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str,
        results: &amp;Sender&lt;Message&gt;) -&gt; Result&lt;()&gt;
{
    let file = try!(File::open(path));
    let buffered = BufReader::new(file);
    for line in buffered.lines() {
        let line = try!(line);
        if line.contains(pattern) {
            <span class="highlighted">results.send(Message::Hit(line)).unwrap();</span>
        }
    }
    return Ok(());
}
</code></pre></div></section><section class="slide"><div><h2>The grep message type</h2><pre><code>enum Message&lt;'a&gt; {
    Hit(String),
    Done(&amp;'a str, Result&lt;()&gt;),
}
</code></pre></div></section><section class="slide"><div><h2>The grep message type</h2><pre><code>enum Message&lt;'a&gt; {
    <span class="highlighted">Hit(String),</span>
    Done(&amp;'a str, Result&lt;()&gt;),
}
</code></pre></div></section><section class="slide"><div><h2>The grep message type</h2><pre><code>enum Message&lt;'a&gt; {
    Hit(String),
    <span class="highlighted">Done(&amp;'a str, Result&lt;()&gt;),</span>
}
</code></pre></div></section><section class="slide"><div><h2>The grep message type</h2><pre><code>enum Message&lt;<span class="highlighted">'a</span>&gt; {
    Hit(String),
    Done(&amp;<span class="highlighted">'a</span> str, Result&lt;()&gt;),
}
</code></pre></div></section><section class="slide"><div><h2>A multi-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str,
        results: &amp;Sender&lt;Message&gt;) -&gt; Result&lt;()&gt;
{
    let file = try!(File::open(path));
    let buffered = BufReader::new(file);
    for line in buffered.lines() {
        let line = try!(line);
        if line.contains(pattern) {
            results.send(<span class="highlighted">Message::Hit(line)</span>).unwrap();
        }
    }
    return Ok(());
}
</code></pre></div></section><section class="slide"><div><h2>A multi-threaded grep</h2><pre><code>fn grep(path: &amp;str, pattern: &amp;str,
        results: &amp;Sender&lt;Message&gt;) -&gt; <span class="highlighted">Result&lt;()&gt;</span>
{
    let file = <span class="highlighted">try!</span>(File::open(path));
    let buffered = BufReader::new(file);
    for line in buffered.lines() {
        let line = <span class="highlighted">try!</span>(line);
        if line.contains(pattern) {
            results.send(Message::Hit(line)).unwrap();
        }
    }
    return <span class="highlighted">Ok(())</span>;
}
</code></pre></div></section><section class="slide"><div><h2>A multi-threaded grep</h2><pre><code>let mut pool = scoped_threadpool::Pool::new(8);
let files : Vec&lt;String&gt; = args.collect();
let (results_tx, results_rx) = channel();
</code></pre></div></section><section class="slide"><div><h2>A multi-threaded grep</h2><pre><code>let mut pool = <span class="highlighted">scoped_threadpool::Pool::new(8);</span>
let files : Vec&lt;String&gt; = args.collect();
let (results_tx, results_rx) = channel();
</code></pre></div></section><section class="slide"><div><h2>A multi-threaded grep</h2><pre><code>let mut pool = scoped_threadpool::Pool::new(8);
<span class="highlighted">let files : Vec&lt;String&gt; = args.collect();</span>
let (results_tx, results_rx) = channel();
</code></pre></div></section><section class="slide"><div><h2>A multi-threaded grep</h2><pre><code>// single-threaded version
<span class="highlighted">for file in args</span> {
    match grep(&amp;file, &amp;pattern) {
        Err(e) =&gt; {
            writeln!(std::io::stderr(),
                     &quot;Error searching {}: {}&quot;, file, e)
                .unwrap();
        },
        Ok(_) =&gt; ()
    }
}
</code></pre></div></section><section class="slide"><div><h2>A multi-threaded grep</h2><pre><code>let mut pool = scoped_threadpool::Pool::new(8);
<span class="highlighted">let files : Vec&lt;String&gt; = args.collect();</span>

pool.scoped(|scope| { ... });
</code></pre></div></section><section class="slide"><div><h2>A multi-threaded grep</h2><pre><code>let mut pool = scoped_threadpool::Pool::new(8);
let files : Vec&lt;String&gt; = args.collect();

<span class="highlighted">pool.scoped</span>(|scope| { ... });
</code></pre></div></section><section class="slide"><div><h2>A multi-threaded grep</h2><pre><code>let mut pool = scoped_threadpool::Pool::new(8);
let files : Vec&lt;String&gt; = args.collect();

pool.scoped(<span class="highlighted">|scope| { ... }</span>);
</code></pre></div></section><section class="slide"><div><h2>a multi-threaded grep</h2><pre><code>pool.scoped(|scope| {
    let receiver;
    {
        let (sender, recv) = std::sync::mpsc::channel();
        receiver = recv;

        ... enqueue search tasks ...
    }

    for message in receiver {
        ... process results ...
    }
})
</code></pre></div></section><section class="slide"><div><h2>a multi-threaded grep</h2><pre><code>pool.scoped(|scope| {
    let receiver;
    {
        let (sender, recv) = <span class="highlighted">std::sync::mpsc::channel()</span>;
        receiver = recv;

        ... enqueue search tasks ...
    }

    for message in receiver {
        ... process results ...
    }
})
</code></pre></div></section><section class="slide"><div><h2>a multi-threaded grep</h2><pre><code>pool.scoped(|scope| {
    let receiver;
    {
        let <span class="highlighted">(sender, recv)</span> = std::sync::mpsc::channel();
        receiver = recv;

        ... enqueue search tasks ...
    }

    for message in receiver {
        ... process results ...
    }
})
</code></pre></div></section><section class="slide"><div><h2>a multi-threaded grep</h2><pre><code>pool.scoped(|scope| {
    let receiver;
    {
        let (<span class="highlighted">sender</span>, recv) = std::sync::mpsc::channel();
        receiver = recv;

        ... enqueue search tasks ...
    }

    for message in receiver {
        ... process results ...
    }
})
</code></pre></div></section><section class="slide"><div><h2>a multi-threaded grep</h2><pre><code>pool.scoped(|scope| {
    let <span class="highlighted">receiver</span>;
    {
        let (sender, recv) = std::sync::mpsc::channel();
        <span class="highlighted">receiver</span> = recv;

        ... enqueue search tasks ...
    }

    for message in <span class="highlighted">receiver</span> {
        ... process results ...
    }
})
</code></pre></div></section><section class="slide"><div><h2>enqueuing search tasks</h2><pre><code>for file in &amp;files {
    let pattern_ref = &amp;pattern;
    let sender_clone = sender.clone();
    scope.execute(move || {
        let result = grep(file, pattern_ref, &amp;sender_clone);
        sender_clone.send(Message::Done(file, result))
            .expect(&quot;receiver died&quot;);
    });
}
</code></pre></div></section><section class="slide"><div><h2>enqueuing search tasks</h2><pre><code><span class="highlighted">for file in &amp;files</span> {
    let pattern_ref = &amp;pattern;
    let sender_clone = sender.clone();
    scope.execute(move || {
        let result = grep(file, pattern_ref, &amp;sender_clone);
        sender_clone.send(Message::Done(file, result))
            .expect(&quot;receiver died&quot;);
    });
}
</code></pre></div></section><section class="slide"><div><h2>enqueuing search tasks</h2><pre><code>for file in &amp;files {
    let pattern_ref = &amp;pattern;
    let sender_clone = <span class="highlighted">sender.clone()</span>;
    scope.execute(move || {
        let result = grep(file, pattern_ref, &amp;sender_clone);
        sender_clone.send(Message::Done(file, result))
            .expect(&quot;receiver died&quot;);
    });
}
</code></pre></div></section><section class="slide"><div><h2>enqueuing search tasks</h2><pre><code>for file in &amp;files {
    let pattern_ref = &amp;pattern;
    let sender_clone = sender.clone();
    <span class="highlighted">scope.execute</span>(move || {
        let result = grep(file, pattern_ref, &amp;sender_clone);
        sender_clone.send(Message::Done(file, result))
            .expect(&quot;receiver died&quot;);
    });
}
</code></pre></div></section><section class="slide"><div><h2>enqueuing search tasks</h2><pre><code>for file in &amp;files {
    let pattern_ref = &amp;pattern;
    let sender_clone = sender.clone();
    scope.execute(<span class="highlighted">move</span> || {
        let result = grep(file, pattern_ref, &amp;sender_clone);
        sender_clone.send(Message::Done(file, result))
            .expect(&quot;receiver died&quot;);
    });
}
</code></pre></div></section><section class="slide"><div><h2>enqueuing search tasks</h2><pre><code>for file in &amp;files {
    let pattern_ref = &amp;pattern;
    let sender_clone = sender.clone();
    scope.execute(move <span class="highlighted">||</span> {
        let result = grep(file, pattern_ref, &amp;sender_clone);
        sender_clone.send(Message::Done(file, result))
            .expect(&quot;receiver died&quot;);
    });
}
</code></pre></div></section><section class="slide"><div><h2>enqueuing search tasks</h2><pre><code>for file in &amp;files {
    let pattern_ref = &amp;pattern;
    let sender_clone = sender.clone();
    scope.execute(move || {
        let result = <span class="highlighted">grep(file, pattern_ref, &amp;sender_clone)</span>;
        sender_clone.send(Message::Done(file, result))
            .expect(&quot;receiver died&quot;);
    });
}
</code></pre></div></section><section class="slide"><div><h2>enqueuing search tasks</h2><pre><code>for file in &amp;files {
    let pattern_ref = &amp;pattern;
    let sender_clone = sender.clone();
    scope.execute(move || {
        let <span class="highlighted">result</span> = grep(file, pattern_ref, &amp;sender_clone);
        sender_clone.send(Message::Done(file, result))
            .expect(&quot;receiver died&quot;);
    });
}
</code></pre></div></section><section class="slide"><div><h2>enqueuing search tasks</h2><pre><code>for file in &amp;files {
    let pattern_ref = &amp;pattern;
    let sender_clone = sender.clone();
    scope.execute(move || {
        let result = grep(file, pattern_ref, &amp;sender_clone);
        sender_clone.send(<span class="highlighted">Message::Done(file, result)</span>)
            .expect(&quot;receiver died&quot;);
    });
}
</code></pre></div></section><section class="slide"><div><h2>processing search results</h2><pre><code>for message in receiver {
    match message {
        Message::Hit(line) =&gt; { println!(&quot;{}&quot;, line); }
        Message::Done(file, result) =&gt; {
            if let Err(e) = result {
                writeln!(std::io::stderr(),
                         &quot;Error searching {}: {}&quot;, file, e)
                    .unwrap();
            }
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>processing search results</h2><pre><code>for message in <span class="highlighted">receiver</span> {
    match message {
        Message::Hit(line) =&gt; { println!(&quot;{}&quot;, line); }
        Message::Done(file, result) =&gt; {
            if let Err(e) = result {
                writeln!(std::io::stderr(),
                         &quot;Error searching {}: {}&quot;, file, e)
                    .unwrap();
            }
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>processing search results</h2><pre><code>for message in receiver {
    <span class="highlighted">match message</span> {
        Message::Hit(line) =&gt; { println!(&quot;{}&quot;, line); }
        Message::Done(file, result) =&gt; {
            if let Err(e) = result {
                writeln!(std::io::stderr(),
                         &quot;Error searching {}: {}&quot;, file, e)
                    .unwrap();
            }
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>processing search results</h2><pre><code>for message in receiver {
    match message {
        <span class="highlighted">Message::Hit(line)</span> =&gt; { println!(&quot;{}&quot;, line); }
        Message::Done(file, result) =&gt; {
            if let Err(e) = result {
                writeln!(std::io::stderr(),
                         &quot;Error searching {}: {}&quot;, file, e)
                    .unwrap();
            }
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>processing search results</h2><pre><code>for message in receiver {
    match message {
        Message::Hit(line) =&gt; { println!(&quot;{}&quot;, line); }
        <span class="highlighted">Message::Done(file, result)</span> =&gt; {
            if let Err(e) = result {
                writeln!(std::io::stderr(),
                         &quot;Error searching {}: {}&quot;, file, e)
                    .unwrap();
            }
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>processing search results</h2><pre><code>for message in receiver {
    match message {
        Message::Hit(line) =&gt; { println!(&quot;{}&quot;, line); }
        Message::Done(file, result) =&gt; {
            <span class="highlighted">if let Err(e) = result</span> {
                writeln!(std::io::stderr(),
                         &quot;Error searching {}: {}&quot;, file, e)
                    .unwrap();
            }
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>It works!</h2></div></section><section class="slide"><div><h2>Looks the same as C++.</h2><p class="next">Yes; Rust isn't a new paradigm for concurrency.
</p><p class="next">... but this program ran correctly the first time it compiled.
</p></div></section><section class="slide"><div><h2>What does this show?</h2><ul><li class="next">Worker pools can manage large tasks with a bounded number of threads.</li><li class="next">Channels are a convenient way to carry messages between threads.</li><li class="next">We can throw pointers around between threads without fear.</li><li class="next">Concurrent Rust programs are still non-deterministic, but the non-determinism occurs only at operations designed for it—not just anywhere.</li></ul></div></section><section class="slide"><div><h2>A bit of pure math</h2><img alt="" src="images/squaring-0.svg"/></div></section><section class="slide"><div><h2>A bit of pure math</h2><img alt="" src="images/squaring-1.svg"/></div></section><section class="slide"><div><h2>A bit of pure math</h2><img alt="" src="images/squaring-2.svg"/></div></section><section class="slide"><div><h2>A bit of pure math</h2><img alt="" src="images/squaring-3.svg"/></div></section><section class="slide"><div><h2>A bit of pure math</h2><img alt="" src="images/squaring-4.svg"/></div></section><section class="slide"><div><h2>A bit of pure math</h2><img alt="" src="images/squaring-5.svg"/></div></section><section class="slide"><div><h2>A bit of pure math</h2><img alt="" src="images/squaring-6.svg"/></div></section><section class="slide"><div><h2>A bit of pure math</h2><img alt="" src="images/squaring-7.svg"/></div></section><section class="slide"><div><h2>A bit of pure math</h2><img alt="" src="images/squaring-8.svg"/></div></section><section class="slide"><div><h2>a variation</h2><pre><code>fn m(c: f64) {
    z = 0;
    loop {
        z = z*z + c;
    }
}
</code></pre><p class="next">Unless -2 ≤ c ≤ 0.25, z escapes.
</p></div></section><section class="slide"><div><h2>a Complex variation</h2><pre><code>fn m(c: Complex&lt;f64&gt;) {
    z = Complex { re: 0., im: 0. };
    loop {
        z = z*z + c;
    }
}
</code></pre><p class="next">... it's complicated.
</p></div></section><section class="slide cover bigpicture"><div><img alt="" src="images/mandelbrot.png"/></div></section><section class="slide"><div><h2>the Mandelbrot escape calculation</h2><pre><code>fn escapes(c: Complex&lt;f64&gt;, limit: u32) -&gt; Option&lt;u32&gt; {
    let mut z = Complex { re: 0.0, im: 0.0 };
    for i in 0..limit {
        z = z*z + c;
        if z.norm_sqr() &gt; 4.0 {
            return Some(i);
        }
    }

    return None;
}
</code></pre></div></section><section class="slide"><div><h2>the Mandelbrot escape calculation</h2><pre><code>fn escapes(c: Complex&lt;f64&gt;, limit: u32) -&gt; <span class="highlighted">Option&lt;u32&gt;</span> {
    let mut z = Complex { re: 0.0, im: 0.0 };
    for i in 0..limit {
        z = z*z + c;
        if z.norm_sqr() &gt; 4.0 {
            return Some(i);
        }
    }

    return None;
}
</code></pre></div></section><section class="slide"><div><h2>the Mandelbrot escape calculation</h2><pre><code>fn escapes(c: Complex&lt;f64&gt;, <span class="highlighted">limit: u32</span>) -&gt; Option&lt;u32&gt; {
    let mut z = Complex { re: 0.0, im: 0.0 };
    <span class="highlighted">for i in 0..limit</span> {
        z = z*z + c;
        if z.norm_sqr() &gt; 4.0 {
            return Some(i);
        }
    }

    return None;
}
</code></pre></div></section><section class="slide"><div><h2>the Mandelbrot escape calculation</h2><pre><code>fn escapes(c: Complex&lt;f64&gt;, limit: u32) -&gt; Option&lt;u32&gt; {
    let mut z = Complex { re: 0.0, im: 0.0 };
    for i in 0..limit {
        z = z*z + c;
        <span class="highlighted">if z.norm_sqr() &gt; 4.0</span> {
            return Some(i);
        }
    }

    return None;
}
</code></pre></div></section><section class="slide"><div><h2>the Mandelbrot escape calculation</h2><pre><code>fn escapes(c: Complex&lt;f64&gt;, limit: u32) -&gt; Option&lt;u32&gt; {
    let mut z = Complex { re: 0.0, im: 0.0 };
    for i in 0..limit {
        z = z*z + c;
        if z.norm_sqr() &gt; 4.0 {
            return Some(i);
        }
    }

    <span class="highlighted">return None;</span>
}
</code></pre></div></section><section class="slide"><div><h2>mapping pixels to points</h2><pre><code>fn pixel_to_point(bounds: (usize, usize),
                  pixel:  (usize, usize),
                  ul: (f64, f64),
                  lr: (f64, f64))
    -&gt; (f64, f64)
{
    let (width, height) = (lr.0 - ul.0,
                           ul.1 - lr.1);
    (ul.0 + pixel.0 as f64 * width  / bounds.0 as f64,
     ul.1 - pixel.1 as f64 * height / bounds.1 as f64)
}
</code></pre></div></section><section class="slide"><div><h2>mapping pixels to points</h2><pre><code>fn pixel_to_point(<span class="highlighted">bounds: (usize, usize)</span>,
                  pixel:  (usize, usize),
                  ul: (f64, f64),
                  lr: (f64, f64))
    -&gt; (f64, f64)
{
    let (width, height) = (lr.0 - ul.0,
                           ul.1 - lr.1);
    (ul.0 + pixel.0 as f64 * width  / bounds.0 as f64,
     ul.1 - pixel.1 as f64 * height / bounds.1 as f64)
}
</code></pre></div></section><section class="slide"><div><h2>mapping pixels to points</h2><pre><code>fn pixel_to_point(bounds: (usize, usize),
                  <span class="highlighted">pixel:  (usize, usize)</span>,
                  ul: (f64, f64),
                  lr: (f64, f64))
    -&gt; (f64, f64)
{
    let (width, height) = (lr.0 - ul.0,
                           ul.1 - lr.1);
    (ul.0 + pixel.0 as f64 * width  / bounds.0 as f64,
     ul.1 - pixel.1 as f64 * height / bounds.1 as f64)
}
</code></pre></div></section><section class="slide"><div><h2>mapping pixels to points</h2><pre><code>fn pixel_to_point(bounds: (usize, usize),
                  pixel:  (usize, usize),
                  <span class="highlighted">ul: (f64, f64)</span>,
                  lr: (f64, f64))
    -&gt; (f64, f64)
{
    let (width, height) = (lr.0 - ul.0,
                           ul.1 - lr.1);
    (ul.0 + pixel.0 as f64 * width  / bounds.0 as f64,
     ul.1 - pixel.1 as f64 * height / bounds.1 as f64)
}
</code></pre></div></section><section class="slide"><div><h2>mapping pixels to points</h2><pre><code>fn pixel_to_point(bounds: (usize, usize),
                  pixel:  (usize, usize),
                  ul: (f64, f64),
                  <span class="highlighted">lr: (f64, f64)</span>)
    -&gt; (f64, f64)
{
    let (width, height) = (lr.0 - ul.0,
                           ul.1 - lr.1);
    (ul.0 + pixel.0 as f64 * width  / bounds.0 as f64,
     ul.1 - pixel.1 as f64 * height / bounds.1 as f64)
}
</code></pre></div></section><section class="slide"><div><h2>mapping pixels to points</h2><pre><code>fn pixel_to_point(bounds: (usize, usize),
                  pixel:  (usize, usize),
                  ul: (f64, f64),
                  lr: (f64, f64))
    -&gt; <span class="highlighted">(f64, f64)</span>
{
    let (width, height) = (lr.0 - ul.0,
                           ul.1 - lr.1);
    (ul.0 + pixel.0 as f64 * width  / bounds.0 as f64,
     ul.1 - pixel.1 as f64 * height / bounds.1 as f64)
}
</code></pre></div></section><section class="slide"><div><h2>mapping pixels to points</h2><pre><code>fn pixel_to_point(bounds: (usize, usize),
                  pixel:  (usize, usize),
                  ul: (f64, f64),
                  lr: (f64, f64))
    -&gt; (f64, f64)
{
    let (width, height) = (<span class="highlighted">lr.0</span> - <span class="highlighted">ul.0</span>,
                           <span class="highlighted">ul.1</span> - <span class="highlighted">lr.1</span>);
    (<span class="highlighted">ul.0</span> + <span class="highlighted">pixel.0</span> as f64 * width  / <span class="highlighted">bounds.0</span> as f64,
     <span class="highlighted">ul.1</span> - <span class="highlighted">pixel.1</span> as f64 * height / <span class="highlighted">bounds.1</span> as f64)
}
</code></pre></div></section><section class="slide"><div><h2>mapping pixels to points</h2><pre><code>fn pixel_to_point(bounds: (usize, usize),
                  pixel:  (usize, usize),
                  ul: (f64, f64),
                  lr: (f64, f64))
    -&gt; (f64, f64)
{
    let (width, height) = (lr.0 - ul.0,
                           ul.1 - lr.1);
    (ul.0 + pixel.0 <span class="highlighted">as f64</span> * width  / bounds.0 <span class="highlighted">as f64</span>,
     ul.1 - pixel.1 <span class="highlighted">as f64</span> * height / bounds.1 <span class="highlighted">as f64</span>)
}
</code></pre></div></section><section class="slide"><div><h2>rendering the set</h2><pre><code>fn render(pixels: &amp;mut [u8], bounds: (usize, usize),
          ul: (f64, f64), lr: (f64, f64)) {
   for r in 0 .. bounds.1 {
      for c in 0 .. bounds.0 {
         let pt = pixel_to_point(bounds, (c, r), ul, lr);
         let pt = Complex { re: pt.0, im: pt.1 };
         pixels[r * bounds.0 + c] =
            match escapes(pt, 255) {
               None =&gt; 0,
               Some(count) =&gt; 255 - count as u8
            };
      }
   }
}
</code></pre></div></section><section class="slide"><div><h2>rendering the set</h2><pre><code>fn render(pixels: <span class="highlighted">&amp;mut [u8]</span>, bounds: (usize, usize),
          ul: (f64, f64), lr: (f64, f64)) {
   for r in 0 .. bounds.1 {
      for c in 0 .. bounds.0 {
         let pt = pixel_to_point(bounds, (c, r), ul, lr);
         let pt = Complex { re: pt.0, im: pt.1 };
         pixels[r * bounds.0 + c] =
            match escapes(pt, 255) {
               None =&gt; 0,
               Some(count) =&gt; 255 - count as u8
            };
      }
   }
}
</code></pre></div></section><section class="slide"><div><h2>rendering the set</h2><pre><code>fn render(pixels: &amp;mut [u8], bounds: (usize, usize),
          ul: (f64, f64), lr: (f64, f64)) {
   <span class="highlighted">for r in 0 .. bounds.1</span> {
      for c in 0 .. bounds.0 {
         let pt = pixel_to_point(bounds, (c, r), ul, lr);
         let pt = Complex { re: pt.0, im: pt.1 };
         pixels[r * bounds.0 + c] =
            match escapes(pt, 255) {
               None =&gt; 0,
               Some(count) =&gt; 255 - count as u8
            };
      }
   }
}
</code></pre></div></section><section class="slide"><div><h2>rendering the set</h2><pre><code>fn render(pixels: &amp;mut [u8], bounds: (usize, usize),
          ul: (f64, f64), lr: (f64, f64)) {
   for r in 0 .. bounds.1 {
      <span class="highlighted">for c in 0 .. bounds.0</span> {
         let pt = pixel_to_point(bounds, (c, r), ul, lr);
         let pt = Complex { re: pt.0, im: pt.1 };
         pixels[r * bounds.0 + c] =
            match escapes(pt, 255) {
               None =&gt; 0,
               Some(count) =&gt; 255 - count as u8
            };
      }
   }
}
</code></pre></div></section><section class="slide"><div><h2>rendering the set</h2><pre><code>fn render(pixels: &amp;mut [u8], bounds: (usize, usize),
          ul: (f64, f64), lr: (f64, f64)) {
   for r in 0 .. bounds.1 {
      for c in 0 .. bounds.0 {
         let pt = <span class="highlighted">pixel_to_point(bounds, (c, r), ul, lr)</span>;
         let pt = Complex { re: pt.0, im: pt.1 };
         pixels[r * bounds.0 + c] =
            match escapes(pt, 255) {
               None =&gt; 0,
               Some(count) =&gt; 255 - count as u8
            };
      }
   }
}
</code></pre></div></section><section class="slide"><div><h2>rendering the set</h2><pre><code>fn render(pixels: &amp;mut [u8], bounds: (usize, usize),
          ul: (f64, f64), lr: (f64, f64)) {
   for r in 0 .. bounds.1 {
      for c in 0 .. bounds.0 {
         let pt = pixel_to_point(bounds, (c, r), ul, lr);
         let pt = <span class="highlighted">Complex { re: pt.0, im: pt.1 }</span>;
         pixels[r * bounds.0 + c] =
            match escapes(pt, 255) {
               None =&gt; 0,
               Some(count) =&gt; 255 - count as u8
            };
      }
   }
}
</code></pre></div></section><section class="slide"><div><h2>rendering the set</h2><pre><code>fn render(pixels: &amp;mut [u8], bounds: (usize, usize),
          ul: (f64, f64), lr: (f64, f64)) {
   for r in 0 .. bounds.1 {
      for c in 0 .. bounds.0 {
         let pt = pixel_to_point(bounds, (c, r), ul, lr);
         let pt = Complex { re: pt.0, im: pt.1 };
         pixels[r * bounds.0 + c] =
            match <span class="highlighted">escapes(pt, 255)</span> {
               None =&gt; 0,
               Some(count) =&gt; 255 - count as u8
            };
      }
   }
}
</code></pre></div></section><section class="slide"><div><h2>rendering the set</h2><pre><code>fn render(pixels: &amp;mut [u8], bounds: (usize, usize),
          ul: (f64, f64), lr: (f64, f64)) {
   for r in 0 .. bounds.1 {
      for c in 0 .. bounds.0 {
         let pt = pixel_to_point(bounds, (c, r), ul, lr);
         let pt = Complex { re: pt.0, im: pt.1 };
         pixels[r * bounds.0 + c] =
            match escapes(pt, 255) {
               <span class="highlighted">None =&gt; 0</span>,
               Some(count) =&gt; 255 - count as u8
            };
      }
   }
}
</code></pre></div></section><section class="slide"><div><h2>rendering the set</h2><pre><code>fn render(pixels: &amp;mut [u8], bounds: (usize, usize),
          ul: (f64, f64), lr: (f64, f64)) {
   for r in 0 .. bounds.1 {
      for c in 0 .. bounds.0 {
         let pt = pixel_to_point(bounds, (c, r), ul, lr);
         let pt = Complex { re: pt.0, im: pt.1 };
         pixels[r * bounds.0 + c] =
            match escapes(pt, 255) {
               None =&gt; 0,
               <span class="highlighted">Some(count) =&gt; 255 - count as u8</span>
            };
      }
   }
}
</code></pre></div></section><section class="slide"><div><h2>rendering the set</h2><pre><code>fn render(pixels: &amp;mut [u8], bounds: (usize, usize),
          ul: (f64, f64), lr: (f64, f64)) {
   for r in 0 .. bounds.1 {
      for c in 0 .. bounds.0 {
         let pt = pixel_to_point(bounds, (c, r), ul, lr);
         let pt = Complex { re: pt.0, im: pt.1 };
         <span class="highlighted">pixels[r * bounds.0 + c]</span> =
            match escapes(pt, 255) {
               None =&gt; 0,
               Some(count) =&gt; 255 - count as u8
            };
      }
   }
}
</code></pre></div></section><section class="slide"><div><h2>writing the image file</h2><pre><code>fn write_bitmap(filename: &amp;str,
                pixels: &amp;[u8],
                bounds: (usize, usize))
    -&gt; Result&lt;()&gt;
{
    let output = try!(File::create(filename));
    let encoder = PNGEncoder::new(output);
    try!(encoder.encode(pixels,
                        bounds.0 as u32, bounds.1 as u32,
                        ColorType::Gray(8)));
    Ok(())
}
</code></pre></div></section><section class="slide"><div><h2>writing the image file</h2><pre><code>fn write_bitmap(filename: &amp;str,
                pixels: &amp;[u8],
                bounds: (usize, usize))
    -&gt; Result&lt;()&gt;
{
    let output = try!(<span class="highlighted">File::create(filename)</span>);
    let encoder = PNGEncoder::new(output);
    try!(encoder.encode(pixels,
                        bounds.0 as u32, bounds.1 as u32,
                        ColorType::Gray(8)));
    Ok(())
}
</code></pre></div></section><section class="slide"><div><h2>writing the image file</h2><pre><code>fn write_bitmap(filename: &amp;str,
                pixels: &amp;[u8],
                bounds: (usize, usize))
    -&gt; Result&lt;()&gt;
{
    let output = try!(File::create(filename));
    let encoder = <span class="highlighted">PNGEncoder::new(output)</span>;
    try!(encoder.encode(pixels,
                        bounds.0 as u32, bounds.1 as u32,
                        ColorType::Gray(8)));
    Ok(())
}
</code></pre></div></section><section class="slide"><div><h2>writing the image file</h2><pre><code>fn write_bitmap(filename: &amp;str,
                pixels: &amp;[u8],
                bounds: (usize, usize))
    -&gt; Result&lt;()&gt;
{
    let output = try!(File::create(filename));
    let encoder = PNGEncoder::new(output);
    try!(<span class="highlighted">encoder.encode</span>(pixels,
                        bounds.0 as u32, bounds.1 as u32,
                        ColorType::Gray(8)));
    Ok(())
}
</code></pre></div></section><section class="slide"><div><h2>writing the image file</h2><pre><code>fn write_bitmap(filename: &amp;str,
                pixels: &amp;[u8],
                bounds: (usize, usize))
    -&gt; Result&lt;()&gt;
{
    let output = try!(File::create(filename));
    let encoder = PNGEncoder::new(output);
    try!(encoder.encode(pixels,
                        bounds.0 as u32, bounds.1 as u32,
                        <span class="highlighted">ColorType::Gray(8)</span>));
    Ok(())
}
</code></pre></div></section><section class="slide"><div><h2>banding the Mandelbrot</h2><img alt="" src="images/sliced-mandelbrot.svg"/></div></section><section class="slide"><div><h2>banded driver</h2><pre><code>let bands : Vec&lt;_&gt;
    = pixels.chunks_mut(band_rows * bounds.0).collect();
crossbeam::scope(|scope| {
    for (i, band) in bands.into_iter().enumerate() {
        let top = band_rows * i;
        let height = band.len() / bounds.0;
        let band_bounds = (bounds.0, height);
        let (band_ul, band_lr) = ...;
        scope.spawn(move || {
            render(band, band_bounds, band_ul, band_lr);
        });
    }
});
</code></pre></div></section><section class="slide"><div><h2>banded driver</h2><pre><code>let bands : Vec&lt;_&gt;
    = <span class="highlighted">pixels.chunks_mut</span>(band_rows * bounds.0).collect();
crossbeam::scope(|scope| {
    for (i, band) in bands.into_iter().enumerate() {
        let top = band_rows * i;
        let height = band.len() / bounds.0;
        let band_bounds = (bounds.0, height);
        let (band_ul, band_lr) = ...;
        scope.spawn(move || {
            render(band, band_bounds, band_ul, band_lr);
        });
    }
});
</code></pre></div></section><section class="slide"><div><h2>banded driver</h2><pre><code>let bands : Vec&lt;_&gt;
    = pixels.chunks_mut(<span class="highlighted">band_rows * bounds.0</span>).collect();
crossbeam::scope(|scope| {
    for (i, band) in bands.into_iter().enumerate() {
        let top = band_rows * i;
        let height = band.len() / bounds.0;
        let band_bounds = (bounds.0, height);
        let (band_ul, band_lr) = ...;
        scope.spawn(move || {
            render(band, band_bounds, band_ul, band_lr);
        });
    }
});
</code></pre></div></section><section class="slide"><div><h2>banded driver</h2><pre><code>let bands <span class="highlighted">: Vec&lt;_&gt;</span>
    = pixels.chunks_mut(band_rows * bounds.0).collect();
crossbeam::scope(|scope| {
    for (i, band) in bands.into_iter().enumerate() {
        let top = band_rows * i;
        let height = band.len() / bounds.0;
        let band_bounds = (bounds.0, height);
        let (band_ul, band_lr) = ...;
        scope.spawn(move || {
            render(band, band_bounds, band_ul, band_lr);
        });
    }
});
</code></pre></div></section><section class="slide"><div><h2>banded driver</h2><pre><code>let bands : Vec&lt;_&gt;
    = pixels.chunks_mut(band_rows * bounds.0).collect();
<span class="highlighted">crossbeam::scope</span>(|scope| {
    for (i, band) in bands.into_iter().enumerate() {
        let top = band_rows * i;
        let height = band.len() / bounds.0;
        let band_bounds = (bounds.0, height);
        let (band_ul, band_lr) = ...;
        scope.spawn(move || {
            render(band, band_bounds, band_ul, band_lr);
        });
    }
});
</code></pre></div></section><section class="slide"><div><h2>banded driver</h2><pre><code>let bands : Vec&lt;_&gt;
    = pixels.chunks_mut(band_rows * bounds.0).collect();
crossbeam::scope(|scope| {
    for (i, band) in <span class="highlighted">bands.into_iter()</span>.enumerate() {
        let top = band_rows * i;
        let height = band.len() / bounds.0;
        let band_bounds = (bounds.0, height);
        let (band_ul, band_lr) = ...;
        scope.spawn(move || {
            render(band, band_bounds, band_ul, band_lr);
        });
    }
});
</code></pre></div></section><section class="slide"><div><h2>banded driver</h2><pre><code>let bands : Vec&lt;_&gt;
    = pixels.chunks_mut(band_rows * bounds.0).collect();
crossbeam::scope(|scope| {
    for <span class="highlighted">(i, band)</span> in bands.into_iter().<span class="highlighted">enumerate()</span> {
        let top = band_rows * i;
        let height = band.len() / bounds.0;
        let band_bounds = (bounds.0, height);
        let (band_ul, band_lr) = ...;
        scope.spawn(move || {
            render(band, band_bounds, band_ul, band_lr);
        });
    }
});
</code></pre></div></section><section class="slide"><div><h2>banded driver</h2><pre><code>let bands : Vec&lt;_&gt;
    = pixels.chunks_mut(band_rows * bounds.0).collect();
crossbeam::scope(|scope| {
    for (i, band) in bands.into_iter().enumerate() {
        let top = band_rows * i;
        let height = band.len() / bounds.0;
        let band_bounds = (bounds.0, height);
        let (band_ul, band_lr) = ...;
        <span class="highlighted">scope.spawn</span>(move || {
            render(band, band_bounds, band_ul, band_lr);
        });
    }
});
</code></pre></div></section><section class="slide"><div><h2>banded driver</h2><pre><code>let bands : Vec&lt;_&gt;
    = pixels.chunks_mut(band_rows * bounds.0).collect();
crossbeam::scope(|scope| {
    for (i, band) in bands.into_iter().enumerate() {
        let top = band_rows * i;
        let height = band.len() / bounds.0;
        let band_bounds = (bounds.0, height);
        let (band_ul, band_lr) = ...;
        scope.spawn(move || {
            <span class="highlighted">render(band, band_bounds, band_ul, band_lr)</span>;
        });
    }
});
</code></pre></div></section><section class="slide"><div><h2>banded Mandelbrot speedup</h2><img class="gnuplot" src="images/mandelbrot-8-no-ideal.png"/></div></section><section class="slide"><div><h2>banded Mandelbrot speedup</h2><img class="gnuplot" src="images/mandelbrot-8.png"/></div></section><section class="slide"><div><h2>banded Mandelbrot speedup</h2><img class="gnuplot" src="images/mandelbrot-16.png"/></div></section><section class="slide"><div><h2>banded Mandelbrot speedup</h2><img class="gnuplot" src="images/mandelbrot-100.png"/></div></section><section class="slide"><div><h2>Not all bands are the same</h2><img alt="" src="images/sliced-mandelbrot.svg"/></div></section><section class="slide"><div><h2>banded Mandelbrot speedup</h2><img class="gnuplot" src="images/mandelbrot-100.png"/></div></section><section class="slide"><div><h2>banded Mandelbrot speedup</h2><img class="gnuplot" src="images/mandelbrot-1000.png"/></div></section><section class="slide"><div><h2>dynamic band allocation</h2><img alt="" src="images/dynamic-sliced-mandelbrot.svg"/></div></section><section class="slide"><div><h2>Dynamically allocated bands</h2><pre><code>let bands =
    Mutex::new(pixels.chunks_mut(band_rows * bounds.0)
               .enumerate());
crossbeam::scope(|scope| {
    for i in 0..8 {
        scope.spawn(|| { ... });
    }
});
</code></pre></div></section><section class="slide"><div><h2>Dynamically allocated bands</h2><pre><code>let bands =
    Mutex::new(<span class="highlighted">pixels.chunks_mut</span>(band_rows * bounds.0)
               .enumerate());
crossbeam::scope(|scope| {
    for i in 0..8 {
        scope.spawn(|| { ... });
    }
});
</code></pre></div></section><section class="slide"><div><h2>Dynamically allocated bands</h2><pre><code>let bands =
    <span class="highlighted">Mutex::new</span>(pixels.chunks_mut(band_rows * bounds.0)
               .enumerate());
crossbeam::scope(|scope| {
    for i in 0..8 {
        scope.spawn(|| { ... });
    }
});
</code></pre></div></section><section class="slide"><div><h2>Dynamically allocated bands</h2><pre><code>let bands =
    Mutex::new(pixels.chunks_mut(band_rows * bounds.0)
               .enumerate());
crossbeam::scope(|scope| {
    <span class="highlighted">for i in 0..8</span> {
        scope.spawn(|| { ... });
    }
});
</code></pre></div></section><section class="slide"><div><h2>Dynamically allocated bands</h2><pre><code>scope.spawn(|| {
    loop {
        match {
            let mut guard = bands.lock().unwrap();
            guard.next()
        }
        {
            None =&gt; { return; }
            Some((i, band)) =&gt; { render(band, ...); }
        }
    }
});
</code></pre></div></section><section class="slide"><div><h2>Dynamically allocated bands</h2><pre><code>scope.spawn(|| {
    loop {
        match {
            let mut guard = <span class="highlighted">bands.lock().unwrap()</span>;
            guard.next()
        }
        {
            None =&gt; { return; }
            Some((i, band)) =&gt; { render(band, ...); }
        }
    }
});
</code></pre></div></section><section class="slide"><div><h2>Dynamically allocated bands</h2><pre><code>scope.spawn(|| {
    loop {
        match {
            let mut <span class="highlighted">guard</span> = bands.lock().unwrap();
            guard.next()
        }
        {
            None =&gt; { return; }
            Some((i, band)) =&gt; { render(band, ...); }
        }
    }
});
</code></pre></div></section><section class="slide"><div><h2>Dynamically allocated bands</h2><pre><code>scope.spawn(|| {
    loop {
        match {
            let mut guard = bands.lock().unwrap();
            <span class="highlighted">guard.next()</span>
        }
        {
            None =&gt; { return; }
            Some((i, band)) =&gt; { render(band, ...); }
        }
    }
});
</code></pre></div></section><section class="slide"><div><h2>Dynamically allocated bands</h2><pre><code>scope.spawn(|| {
    loop {
        match {
            let mut guard = bands.lock().unwrap();
            guard.next()
        }
        {
            <span class="highlighted">None =&gt; { return; }</span>
            Some((i, band)) =&gt; { render(band, ...); }
        }
    }
});
</code></pre></div></section><section class="slide"><div><h2>Dynamically allocated bands</h2><pre><code>scope.spawn(|| {
    loop {
        match {
            let mut guard = bands.lock().unwrap();
            guard.next()
        }
        {
            None =&gt; { return; }
            <span class="highlighted">Some((i, band)) =&gt; { render(band, ...); }</span>
        }
    }
});
</code></pre></div></section><section class="slide"><div><h2>dynamic band allocation</h2><img class="gnuplot" src="images/mandelbrot-dynamic-8.png"/></div></section><section class="slide"><div><h2>dynamic band allocation</h2><img class="gnuplot" src="images/mandelbrot-dynamic-16.png"/></div></section><section class="slide"><div><h2>dynamic band allocation</h2><img class="gnuplot" src="images/mandelbrot-dynamic-100.png"/></div></section><section class="slide big"><div><p/><p>Something is still slightly unsatisfying...
</p></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::atomic::Ordering::*;

struct AtomicChunksMut&lt;'a, T: 'a&gt; {
    slice: &amp;'a [T],
    step: usize,
    next: AtomicUsize
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>use std::sync::atomic::{<span class="highlighted">AtomicUsize</span>, Ordering};
use std::sync::atomic::Ordering::*;

struct AtomicChunksMut&lt;'a, T: 'a&gt; {
    slice: &amp;'a [T],
    step: usize,
    next: AtomicUsize
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::atomic::Ordering::*;

<span class="highlighted">struct AtomicChunksMut</span>&lt;'a, T: 'a&gt; {
    slice: &amp;'a [T],
    step: usize,
    next: AtomicUsize
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::atomic::Ordering::*;

struct AtomicChunksMut&lt;'a, T: 'a&gt; {
    <span class="highlighted">slice: &amp;'a [T],</span>
    step: usize,
    next: AtomicUsize
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::atomic::Ordering::*;

struct AtomicChunksMut&lt;'a, T: 'a&gt; {
    slice: &amp;'a [T],
    <span class="highlighted">step: usize,</span>
    next: AtomicUsize
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::atomic::Ordering::*;

struct AtomicChunksMut&lt;'a, T: 'a&gt; {
    slice: &amp;'a [T],
    step: usize,
    <span class="highlighted">next: AtomicUsize</span>
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::atomic::Ordering::*;

struct AtomicChunksMut&lt;<span class="highlighted">'a</span>, T: <span class="highlighted">'a</span>&gt; {
    slice: &amp;<span class="highlighted">'a</span> [T],
    step: usize,
    next: AtomicUsize
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>impl&lt;'a, T&gt; AtomicChunksMut&lt;'a, T&gt; {
    pub fn new(...) { ... }
    unsafe fn next(...) { ... }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code><span class="highlighted">impl</span>&lt;'a, T&gt; <span class="highlighted">AtomicChunksMut</span>&lt;'a, T&gt; {
    pub fn new(...) { ... }
    unsafe fn next(...) { ... }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>impl&lt;'a, T&gt; AtomicChunksMut&lt;'a, T&gt; {
    pub <span class="highlighted">fn new</span>(...) { ... }
    unsafe fn next(...) { ... }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>impl&lt;'a, T&gt; AtomicChunksMut&lt;'a, T&gt; {
    pub fn new(...) { ... }
    unsafe <span class="highlighted">fn next</span>(...) { ... }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>impl&lt;'a, T&gt; AtomicChunksMut&lt;'a, T&gt; {
    pub fn new(slice: &amp;'a mut [T], step: usize)
              -&gt; AtomicChunksMut&lt;'a, T&gt; {
        AtomicChunksMut {             
           slice: slice,              
            step: step,               
            next: AtomicUsize::new(0) 
        }                             
    }
    ...
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>impl&lt;'a, T&gt; AtomicChunksMut&lt;'a, T&gt; {
    <span class="highlighted">pub fn new</span>(slice: &amp;'a mut [T], step: usize)
              -&gt; AtomicChunksMut&lt;'a, T&gt; {
        AtomicChunksMut {             
           slice: slice,              
            step: step,               
            next: AtomicUsize::new(0) 
        }                             
    }
    ...
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>impl&lt;'a, T&gt; AtomicChunksMut&lt;'a, T&gt; {
    pub fn new(slice: &amp;'a mut [T], step: usize)
              -&gt; AtomicChunksMut&lt;'a, T&gt; {
        <span class="highlighted">AtomicChunksMut {             </span>
        <span class="highlighted">   slice: slice,              </span>
        <span class="highlighted">    step: step,               </span>
        <span class="highlighted">    next: AtomicUsize::new(0) </span>
        <span class="highlighted">}                             </span>
    }
    ...
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>impl&lt;'a, T&gt; AtomicChunksMut&lt;'a, T&gt; {
    pub fn new(slice: &amp;'a mut [T], step: usize)
              -&gt; AtomicChunksMut&lt;'a, T&gt; {
        AtomicChunksMut {             
           slice: slice,              
            step: step,               
            next: <span class="highlighted">AtomicUsize::new</span>(0) 
        }                             
    }
    ...
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>unsafe fn next(&amp;self) -&gt; Option&lt;(usize, &amp;'a mut [T])&gt; {
    loop {
        let cur = self.next.load(SeqCst);
        if cur == self.slice.len() { return None; }
        let end = min(cur + self.step, self.slice.len());
        if self.next.compare_and_swap(cur, end, SeqCst)
           == cur {
           return Some((cur / self.step,                   
                        transmute(&amp;self.slice[cur..end])));
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>unsafe fn next(&amp;self) -&gt; <span class="highlighted">Option&lt;(usize, &amp;'a mut [T])&gt;</span> {
    loop {
        let cur = self.next.load(SeqCst);
        if cur == self.slice.len() { return None; }
        let end = min(cur + self.step, self.slice.len());
        if self.next.compare_and_swap(cur, end, SeqCst)
           == cur {
           return Some((cur / self.step,                   
                        transmute(&amp;self.slice[cur..end])));
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>unsafe fn next(&amp;self) -&gt; Option&lt;(usize, &amp;'a mut [T])&gt; {
    loop {
        let cur = <span class="highlighted">self.next.load(SeqCst)</span>;
        if cur == self.slice.len() { return None; }
        let end = min(cur + self.step, self.slice.len());
        if self.next.compare_and_swap(cur, end, SeqCst)
           == cur {
           return Some((cur / self.step,                   
                        transmute(&amp;self.slice[cur..end])));
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>unsafe fn next(&amp;self) -&gt; Option&lt;(usize, &amp;'a mut [T])&gt; {
    loop {
        let cur = self.next.load(SeqCst);
        if <span class="highlighted">cur == self.slice.len()</span> { return None; }
        let end = min(cur + self.step, self.slice.len());
        if self.next.compare_and_swap(cur, end, SeqCst)
           == cur {
           return Some((cur / self.step,                   
                        transmute(&amp;self.slice[cur..end])));
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>unsafe fn next(&amp;self) -&gt; Option&lt;(usize, &amp;'a mut [T])&gt; {
    loop {
        let cur = self.next.load(SeqCst);
        if cur == self.slice.len() { return None; }
        let end = <span class="highlighted">min(cur + self.step, self.slice.len())</span>;
        if self.next.compare_and_swap(cur, end, SeqCst)
           == cur {
           return Some((cur / self.step,                   
                        transmute(&amp;self.slice[cur..end])));
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>unsafe fn next(&amp;self) -&gt; Option&lt;(usize, &amp;'a mut [T])&gt; {
    loop {
        let cur = self.next.load(SeqCst);
        if cur == self.slice.len() { return None; }
        let end = min(cur + self.step, self.slice.len());
        if self.next.<span class="highlighted">compare_and_swap</span>(cur, end, SeqCst)
           == cur {
           return Some((cur / self.step,                   
                        transmute(&amp;self.slice[cur..end])));
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>unsafe fn next(&amp;self) -&gt; Option&lt;(usize, &amp;'a mut [T])&gt; {
    loop {
        let cur = self.next.load(SeqCst);
        if cur == self.slice.len() { return None; }
        let end = min(cur + self.step, self.slice.len());
        if <span class="highlighted">self.next</span>.compare_and_swap(<span class="highlighted">cur</span>, end, SeqCst)
           == cur {
           return Some((cur / self.step,                   
                        transmute(&amp;self.slice[cur..end])));
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>unsafe fn next(&amp;self) -&gt; Option&lt;(usize, &amp;'a mut [T])&gt; {
    loop {
        let cur = self.next.load(SeqCst);
        if cur == self.slice.len() { return None; }
        let end = min(cur + self.step, self.slice.len());
        if self.next.compare_and_swap(cur, <span class="highlighted">end</span>, SeqCst)
           == cur {
           return Some((cur / self.step,                   
                        transmute(&amp;self.slice[cur..end])));
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>unsafe fn next(&amp;self) -&gt; Option&lt;(usize, &amp;'a mut [T])&gt; {
    loop {
        let cur = self.next.load(SeqCst);
        if cur == self.slice.len() { return None; }
        let end = min(cur + self.step, self.slice.len());
        if self.next.compare_and_swap(cur, end, SeqCst)
           <span class="highlighted">== cur</span> {
           return Some((cur / self.step,                   
                        transmute(&amp;self.slice[cur..end])));
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>unsafe fn next(&amp;self) -&gt; Option&lt;(usize, &amp;'a mut [T])&gt; {
    loop {
        let cur = self.next.load(SeqCst);
        if cur == self.slice.len() { return None; }
        let end = min(cur + self.step, self.slice.len());
        if self.next.compare_and_swap(cur, end, SeqCst)
           == cur {
           return <span class="highlighted">Some((cur / self.step,                   </span>
                  <span class="highlighted">      transmute(&amp;self.slice[cur..end])));</span>
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>unsafe fn next(&amp;self) -&gt; Option&lt;(usize, &amp;'a mut [T])&gt; {
    <span class="highlighted">loop</span> {
        let cur = self.next.load(SeqCst);
        if cur == self.slice.len() { return None; }
        let end = min(cur + self.step, self.slice.len());
        if self.next.compare_and_swap(cur, end, SeqCst)
           == cur {
           return Some((cur / self.step,                   
                        transmute(&amp;self.slice[cur..end])));
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>unsafe fn next(&amp;self) -&gt; Option&lt;(usize, <span class="highlighted">&amp;'a mut [T]</span>)&gt; {
    loop {
        let cur = self.next.load(SeqCst);
        if cur == self.slice.len() { return None; }
        let end = min(cur + self.step, self.slice.len());
        if self.next.compare_and_swap(cur, end, SeqCst)
           == cur {
           return Some((cur / self.step,                   
                        <span class="highlighted">transmute</span>(&amp;self.slice[cur..end])));
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code><span class="highlighted">unsafe</span> fn next(&amp;self) -&gt; Option&lt;(usize, &amp;'a mut [T])&gt; {
    loop {
        let cur = self.next.load(SeqCst);
        if cur == self.slice.len() { return None; }
        let end = min(cur + self.step, self.slice.len());
        if self.next.compare_and_swap(cur, end, SeqCst)
           == cur {
           return Some((cur / self.step,                   
                        transmute(&amp;self.slice[cur..end])));
        }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>impl&lt;'a, 'b, T&gt; Iterator for &amp;'b AtomicChunksMut&lt;'a, T&gt; {
    type Item = (usize, &amp;'a mut [T]);
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        unsafe { (*self).next() }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>impl&lt;'a, 'b, T&gt; <span class="highlighted">Iterator</span> for &amp;'b AtomicChunksMut&lt;'a, T&gt; {
    <span class="highlighted">type Item</span> = (usize, &amp;'a mut [T]);
    <span class="highlighted">fn next</span>(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        unsafe { (*self).next() }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>impl&lt;'a, 'b, T&gt; Iterator for &amp;'b AtomicChunksMut&lt;'a, T&gt; {
    type Item = (usize, &amp;'a mut [T]);
    fn next(&amp;mut self) -&gt; <span class="highlighted">Option&lt;Self::Item&gt;</span> {
        unsafe { (*self).next() }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>impl&lt;'a, 'b, T&gt; Iterator for <span class="highlighted">&amp;'b AtomicChunksMut&lt;'a, T&gt;</span> {
    type Item = (usize, &amp;'a mut [T]);
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        unsafe { (*self).next() }
    }
}
</code></pre></div></section><section class="slide"><div><h2>A lock-free chunk iterator</h2><pre><code>impl&lt;'a, 'b, T&gt; Iterator for &amp;'b AtomicChunksMut&lt;'a, T&gt; {
    type Item = (usize, &amp;'a mut [T]);
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        unsafe { <span class="highlighted">(*self).next()</span> }
    }
}
</code></pre></div></section><section class="slide"><div><h2>Lock-free dynamic bands</h2><pre><code>let bands = AtomicChunksMut::new(&amp;mut pixels, bounds.0);
crossbeam::scope(|scope| {
    for i in 0..8 {
        scope.spawn(|| {
            for (i, band) in &amp;bands {
                ...
                render(band, ...);
            }
        });
    }
});
</code></pre></div></section><section class="slide"><div><h2>Lock-free dynamic bands</h2><pre><code>let bands = <span class="highlighted">AtomicChunksMut::new</span>(&amp;mut pixels, bounds.0);
crossbeam::scope(|scope| {
    for i in 0..8 {
        scope.spawn(|| {
            for (i, band) in &amp;bands {
                ...
                render(band, ...);
            }
        });
    }
});
</code></pre></div></section><section class="slide"><div><h2>Lock-free dynamic bands</h2><pre><code>let bands = AtomicChunksMut::new(&amp;mut pixels, bounds.0);
crossbeam::scope(|scope| {
    <span class="highlighted">for i in 0..8</span> {
        scope.spawn(|| {
            for (i, band) in <span class="highlighted">&amp;bands</span> {
                ...
                render(band, ...);
            }
        });
    }
});
</code></pre></div></section><section class="slide"><div><h2>Lock-free dynamic bands</h2><pre><code>let bands = AtomicChunksMut::new(&amp;mut pixels, bounds.0);
crossbeam::scope(|scope| {
    for i in 0..8 {
        scope.spawn(|| {
            <span class="highlighted">for (i, band) in &amp;bands</span> {
                ...
                render(band, ...);
            }
        });
    }
});
</code></pre></div></section><section class="slide"><div><h2>dynamic band allocation</h2><img class="gnuplot" src="images/mandelbrot-lockfree-16.png"/></div></section><section class="slide"><div><h2>Summing up</h2><ul><li class="next">Message-passing works</li><li class="next">Mutexes work.</li><li class="next">Atomics work.</li><li class="next">Never a data race, if you stick to safe code.</li><li class="next">Rust's concurrency primitives are open-ended: when you know what you're doing, you can build new safe primitives from unsafe implementations.Benchmark, and you learn cool stuff.</li></ul></div></section><section class="slide cover bigpicture"><div><img alt="" src="images/subsets-0.svg"/></div></section><section class="slide cover bigpicture"><div><img alt="" src="images/subsets-1.svg"/></div></section><section class="slide cover bigpicture"><div><img alt="" src="images/subsets-2.svg"/></div></section><section class="slide cover bigpicture"><div><img alt="" src="images/subsets-3.svg"/></div></section><section class="slide cover bigpicture"><div><img alt="" src="images/subsets-4.svg"/></div></section><div class="progress"><div/></div><script src="shower/shower.min.js"></script></body></html>
